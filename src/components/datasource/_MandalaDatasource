import { cloneDeep } from 'lodash'
import React from 'react'
import { MandalaDatasourceError } from '../common/exceptions'
import { MandalaJacksonParser } from '@/components/common/json'
import { MandalaObjectHelper } from '@/components/common/helper'
import { format, parse } from 'date-fns'

const dataSourceDatetimeFormat = "YYYY-MM-DDTHH:mm:ss.SSS";
		// this._displayDatetimeFormat = "DD/MM/YYYY HH:mm:ss";
		// this._displayDateFormat = "DD/MM/YYYY";
		// this._displayTimeFormat = "HH:mm:ss";

enum MandalaDatasourceState {
  DS_BROWSE,
  DS_INSERT,
  DS_EDIT
}

type MandalaDatasourceEventListener = {
    event: MandalaDatasourceEventType, 
    dispatch : Function,
    fieldName : string | undefined
}

enum MandalaDatasourceEventType {
  BEFORE_OPEN,
  AFTER_OPEN,
  BEFORE_CLOSE,
  AFTER_CLOSE,
  BEFORE_GOTO_PAGE,
  AFTER_GOTO_PAGE,
  AFTER_SCROLL,
  BEFORE_EDIT,
  BEFORE_DELETE,
  AFTER_EDIT,
  AFTER_DELETE,
  BEFORE_POST,
  AFTER_POST,
  BEFORE_CANCEL,
  AFTER_CANCEL,
  BEFORE_INSERT,
  AFTER_INSERT,
  BEFORE_VALIDATE,
  AFTER_VALIDATE,
  DATA_FIELD_CHANGED,
  ON_ERROR
}

const DATASOURCE_EVENTS: MandalaDatasourceEventType[] = [
  MandalaDatasourceEventType.AFTER_DELETE,
  MandalaDatasourceEventType.BEFORE_OPEN,
  MandalaDatasourceEventType.AFTER_OPEN,
  MandalaDatasourceEventType.BEFORE_CLOSE,
  MandalaDatasourceEventType.AFTER_CLOSE,
  MandalaDatasourceEventType.AFTER_EDIT,
  MandalaDatasourceEventType.AFTER_INSERT,
  MandalaDatasourceEventType.AFTER_CANCEL,
  MandalaDatasourceEventType.ON_ERROR,
  MandalaDatasourceEventType.BEFORE_GOTO_PAGE,
  MandalaDatasourceEventType.AFTER_GOTO_PAGE
]

class MandalaDatasource<T> {
  protected data: T[];
  protected allData: T[];
  protected listeners: MandalaDatasourceEventListener[];
  protected totalPages: number;
  protected currentPage: number;
  protected totalRecords: number;
  protected grandTotalRecords: number;
  protected sizeOfPage: number;
  protected dsState: MandalaDatasourceState;
  protected currentRecord?: T;
  protected currentRecno: number;
  protected primaryKeyFields: string[];
  protected oldRecordInsert?: T;
  protected oldRecnoInsert: number;
  protected active: boolean = false;
  protected contentProperty: string;
  protected totalPagesProperty: string;
  protected currentPageProperty: string;
  protected totalRecordsProperty: string;
  protected sizeOfPageProperty: string;
  protected grandTotalRecordsProperty: string;
  protected _enableListeners: boolean;
  protected dataSourceName: string;
  protected filter: any
  protected arrValues: any

  constructor(name: string) {
    this.data = []
    this.allData = []
    this.listeners = []
    this.totalPages = 0
    this.currentPage = 0
    this.totalRecords = 0
    this.grandTotalRecords = 0
    this.sizeOfPage = 0
    this.dsState = MandalaDatasourceState.DS_BROWSE
    this.currentRecno = -1
    this.primaryKeyFields = []
    this.oldRecnoInsert = -1;
    this.active = false

    this.getTotalPages = this.getTotalPages.bind(this)
    this.contentProperty = 'content'
    this.totalPagesProperty = 'totalPages'
    this.currentPageProperty = 'number'
    this.totalRecordsProperty = 'numberOfElements'
    this.sizeOfPageProperty = 'size'
    this.grandTotalRecordsProperty = 'totalElements'
    this._enableListeners = true

    this.dataSourceName = name
    if (!name) {
      this.dataSourceName = 'ds' + Math.random()
    }
    this.filter = undefined
  }

  public setContentProperty = (name : string) => {
    this.contentProperty = name
  }
  public setTotalPagesProperty = (name : string) => {
    this.totalPagesProperty = name
  }
  public setCurrentPageProperty = (name : string) => {
    this.currentPageProperty = name
  }
  public setTotalRecordsProperty = (name : string) => {
    this.totalRecordsProperty = name
  }
  public setSizeOfPageProperty = (name : string) => {
    this.sizeOfPageProperty = name
  }
  public setGrandTotalRecordsProperty = (name : string) => {
    this.grandTotalRecordsProperty = name
  }

  public open = (data: T[] = [], cloneOnEdit: boolean = false) => {
    this.close()
    this.dispatchEvent(MandalaDatasourceEventType.BEFORE_OPEN)
    this.data = data;
    this.allData = []
    this.active = true
    this.dispatchEvent(MandalaDatasourceEventType.AFTER_OPEN)
  }

  public isOpen = () : boolean => {
    return this.active
  }

  public close = () => {
    if (this.active) {
      this.dispatchEvent(MandalaDatasourceEventType.BEFORE_CLOSE)
      this.active = false
      this.dispatchEvent(MandalaDatasourceEventType.AFTER_CLOSE)
    }
  }

  public getDataSourceName = () : string => {
    return this.dataSourceName
  }

  public getData = () : T[] => {
    return this.data
  }

  public applyFilter = (filter : Function) => {
    this.filter = filter
    this.data = []
    this.data = this.filter
      ? this.allData.filter(this.filter)
      : this.data.concat(this.allData)
    this.first()
  }

  public clearFilter = () => {
    this.filter = undefined
    this.data = []
    this.data.concat(this.allData)
    this.first()
  }

  public getTotalPages = () : number => {
    return this.totalPages
  }

  public getCurrentPage = () : number => {
    return this.currentPage
  }

  public getTotalRecords = () : number => {
    return this.totalRecords
  }

  public getSizeOfPage = () : number => {
    return this.sizeOfPage
  }

  public goToPage = (page) => {
    this.currentPage = page
  }

  public goNextPage = () => {
    this.currentPage = this.currentPage + 1
  }

  public getGrandTotalRecords = () => {
    return this.grandTotalRecords
  }

  public isEmpty = () : boolean => {
    return this.getTotalRecords() === 0
  }

  public getCurrentRecord = () : T | undefined => {
    return this.currentRecord
  }

  public getPrimaryKeyFields = () : string[] => {
    return this.primaryKeyFields
  }

  public getState = () : MandalaDatasourceState => {
    return this.dsState
  }

  public getRecno = () : number => {
    return this.currentRecno
  }
  
  public gotoRecordByPrimaryKey = (values) : T | undefined => {
    if (this.getState() != MandalaDatasourceState.DS_BROWSE) {
      throw new MandalaDatasourceError(
        'Registro atual está sendo inserido ou editado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: gotoRecordByPrimaryKey'
      )
    }
    if (!values) {
      throw new MandalaDatasourceError(
        'Informe os valores da chave primária para ir para um registro. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: gotoRecordByPrimaryKey'
      )
    }
    let arrValues = React.Children.toArray(values)
    if (arrValues.length != this.getPrimaryKeyFields().length) {
      throw new MandalaDatasourceError(
        'Número de valores da chave primária incorretos. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: gotoRecordByPrimaryKey'
      )
    }

    if (!this.primaryKeyFields || this.primaryKeyFields.length === 0) {
      throw new MandalaDatasourceError(
        'Campos da chave primária do Datasource não foram definidas. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: gotoRecordByPrimaryKey'
      )
    }

    if (this.data) {
      let result : T | undefined = undefined
      this.data.forEach((record) => {
        let _record = record
        let _primaryKeyFields = this.getPrimaryKeyFields()
        let found = 0
        this.arrValues.forEach((value, index) => {
          if (_record[_primaryKeyFields[index]] === value) {
            found++
          }
        })
        if (found === _primaryKeyFields.length) {
          result = record
        }
      })
      return result
    }
  }

  public getPrimaryKey = () => {
    let result: any[] = []
    if (!this.isEmpty()) {
      this.primaryKeyFields.forEach((field, index) => {
        if (this.currentRecord)
        result.push({
          field: this.currentRecord[field]
        })
      })
    }
  }

  public gotoRecord = (recno) => {
    if (this.getState() != MandalaDatasourceState.DS_BROWSE) {
      throw new MandalaDatasourceError(
        'Registro atual está sendo inserido ou editado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: gotoRecordByPrimaryKey'
      )
    }

    if (recno === undefined || recno < 0) {
      throw new MandalaDatasourceError(
        'Número do registro informado inválido ' +
          recno +
          ' Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: gotoRecordByPrimaryKey'
      )
    }
    if (this.isEmpty()) {
      throw new MandalaDatasourceError(
        'Não há registros para posicionar. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: gotoRecordByPrimaryKey'
      )
    }

    if (recno > this.getTotalRecords() - 1) {
      throw new MandalaDatasourceError(
        'Número do registro maior que o total de registros. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: gotoRecordByPrimaryKey'
      )
    }

    this.currentRecno = recno
    this.currentRecord = this.data[recno]
    this.dispatchEvent(MandalaDatasourceEventType.AFTER_SCROLL)
  }

  private arrayMove(arr, old_index, new_index) {
    if (new_index >= arr.length) {
      var k = new_index - arr.length + 1
      while (k--) {
        arr.push(undefined)
      }
    }
    arr.splice(new_index, 0, arr.splice(old_index, 1)[0])
    return arr
  }

  public moveRecord = (oldIndex : number, newIndex: number) => {
    if (this.isEmpty()) {
      return false
    }
    if (this.getState() != MandalaDatasourceState.DS_BROWSE) {
      throw new MandalaDatasourceError(
        'Registro atual está sendo inserido ou editado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: moveRecord'
      )
    }
    let record : T | undefined = this.currentRecord
    if (record){
        this.data = this.arrayMove(this.data, oldIndex, newIndex);
        this.gotoRecordByData(record);
    }
  }

  public gotoRecordByData = (record : T) => {
    if (this.getState() != MandalaDatasourceState.DS_BROWSE) {
      throw new MandalaDatasourceError(
        'Registro atual está sendo inserido ou editado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: moveRecord'
      )
    }

    if (this.isEmpty()) {
      return false
    }
    if (this.currentRecord === record) {
      return true
    }

    let found = false
    this.data.forEach((r, index) => {
      if (record === r) {
        this.currentRecno = index
        this.currentRecord = r
        this.dispatchEvent(MandalaDatasourceEventType.AFTER_SCROLL)
        found = true
      }
    })
    return found
  }

  public isEmptyField = (fieldName: string) : boolean => {
    if (!fieldName) {
      throw new MandalaDatasourceError(
        'Nome do campo não pode ser nulo. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: isEmptyField'
      )
    }
    return (
      this.fieldByName(fieldName) === undefined ||
      this.fieldByName(fieldName) === ''
    )
  }

  public fieldByName = (fieldName: string, defaultValue: any | undefined = undefined) : any => {
    if (!fieldName) {
      throw new MandalaDatasourceError(
        'Nome do campo inválido. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: fieldByName'
      )
    }
    if (this.isEmpty()) {
      return
    }
    if (this.isBOF()) {
      throw new MandalaDatasourceError(
        'Inicio do Datasource encontrado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: fieldByName'
      )
    }
    if (this.isEOF()) {
      throw new MandalaDatasourceError(
        'Fim do Datasource encontrado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: fieldByName'
      )
    }

    let record : T | undefined = this.data[this.currentRecno]
    if (this.getState() === MandalaDatasourceState.DS_EDIT) {
      record = this.currentRecord
    }

    let value = this._fieldByName(record, fieldName)
    if (value === undefined && defaultValue !== undefined) {
      value = defaultValue
    }
    return value
  }

  private _fieldByName(record, fieldName) : any {
    let value = MandalaObjectHelper.getNestedProperty(record, fieldName)
    if (value === undefined) {
      return
    }
    return parse(value, dataSourceDatetimeFormat, new Date());
  }

  public setFieldByName = (fieldName : string, value : any) => {
    if (this.isEmpty()) {
      return
    }
    if (this.getState() === MandalaDatasourceState.DS_BROWSE) {
      throw new MandalaDatasourceError(
        'Registro não está sendo inserido ou editado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: setFieldByName'
      )
    }

    if (!fieldName) {
      throw new MandalaDatasourceError(
        'Nome do campo não pode ser nulo. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: setFieldByName'
      )
    }

    let newValue = value
    if (value instanceof Date) {
      newValue = format(value,dataSourceDatetimeFormat);
    }
    var split = fieldName.split('.')
    if (split.length > 1) {
      MandalaObjectHelper.setNestedProperty(
        this.currentRecord,
        fieldName,
        newValue
      )
    } else {
        if (this.currentRecord) {
            this.currentRecord[fieldName] = newValue;
        }
    }

    this.dispatchEvent(
      MandalaDatasourceEventType.DATA_FIELD_CHANGED,
      null,
      fieldName
    )
  }

  public locate = (values : any) : boolean => {
    if (this.getState() != MandalaDatasourceState.DS_BROWSE) {
      throw new MandalaDatasourceError(
        'Registro atual está sendo inserido ou editado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: locate'
      )
    }

    if (this.isEmpty()) {
      return false
    }

    let found = -1
    let index = -1
    this.data.forEach((record) => {
      index++
      for (var propertyName in values) {
        if (this._fieldByName(record, propertyName) === values[propertyName]) {
          found = index
        }
      }
    })

    if (found >= 0) {
      this.gotoRecord(found)
    }
    return found >= 0
  }

  public isEOF = () : boolean => {
    return this.currentRecno > this.totalRecords - 1 || this.isEmpty()
  }

  public isBOF = () : boolean => {
    return this.currentRecno === -1
  }

  public isFirst = () : boolean => {
    return this.currentRecno === 0
  }

  public isLast = () : boolean => {
    return this.currentRecno === this.getTotalRecords() - 1
  }

  public first = () => {
    if (this.getState() != MandalaDatasourceState.DS_BROWSE) {
      throw new MandalaDatasourceError(
        'Registro atual está sendo inserido ou editado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: first'
      )
    }

    if (this.getTotalRecords() > 0) {
      this.currentRecno = 0
      this.currentRecord = this.data[this.currentRecno]
      this.dispatchEvent(MandalaDatasourceEventType.AFTER_SCROLL)
    } else {
      this.currentRecno = -1
      this.currentRecord = undefined
    }
  }

  public last  = () => {
    if (this.getState() != MandalaDatasourceState.DS_BROWSE) {
      throw new MandalaDatasourceError(
        'Registro atual está sendo inserido ou editado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: last'
      )
    }

    if (this.getTotalRecords() > 0) {
      this.currentRecno = this.getTotalRecords() - 1
      this.currentRecord = this.data[this.currentRecno]
      this.dispatchEvent(MandalaDatasourceEventType.AFTER_SCROLL)
    } else {
      this.currentRecno = -1
      this.currentRecord = undefined
    }
  }

  public next = () => {
    if (this.getState() != MandalaDatasourceState.DS_BROWSE) {
      throw new MandalaDatasourceError(
        'Registro atual está sendo inserido ou editado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: next'
      )
    }

    if (this.isEmpty()) {
      throw new MandalaDatasourceError(
        'Não há registros. Impossível avançar um registro. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: next'
      )
    }
    if (this.isEOF()) {
      throw new MandalaDatasourceError(
        'Não é possível avançar pois você já está no final do DataSource. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: next'
      )
    }
    if (this.currentRecno + 1 > this.getTotalRecords() - 1) {
      this.currentRecno = this.currentRecno + 1
      this.currentRecord = undefined
    } else {
      this.currentRecno = this.currentRecno + 1
      this.currentRecord = this.data[this.currentRecno]
      this.dispatchEvent(MandalaDatasourceEventType.AFTER_SCROLL)
    }
  }

  public prior = () => {
    if (this.getState() != MandalaDatasourceState.DS_BROWSE) {
      throw new MandalaDatasourceError(
        'Registro atual está sendo inserido ou editado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: prior'
      )
    }

    if (this.isEmpty()) {
      throw new MandalaDatasourceError(
        'Não há registros. Impossível voltar um registro. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: prior'
      )
    }
    if (this.isBOF()) {
      throw new MandalaDatasourceError(
        'Não é possível retroceder pois você já está no inicio do DataSource. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: prior'
      )
    }
    if (this.currentRecno - 1 < 0) {
      this.currentRecno = -1
      this.currentRecord = undefined
    } else {
      this.currentRecno = this.currentRecno - 1
      this.currentRecord = this.data[this.currentRecno]
      this.dispatchEvent(MandalaDatasourceEventType.AFTER_SCROLL)
    }
  }

  public previous = () => {
    this.prior()
  }

  public hasNext = () : boolean => {
    if (this.isEmpty() || this.isEOF()) {
      return false
    } else {
      return this.currentRecno + 1 <= this.getTotalRecords() - 1
    }
  }

  public hasPrior = () : boolean => {
    if (this.isEmpty() || this.isBOF()) {
      return false
    } else {
      return this.currentRecno - 1 >= 0
    }
  }

  public hasPrevious = () : boolean => {
    return this.hasPrior()
  }

  private _validateInsert = () => {
    if (!this.isOpen()) {
      throw new MandalaDatasourceError(
        'Não é possível realizar INSERT com o dataSource fechado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: _validateInsert'
      )
    }
    if (this.getState() === MandalaDatasourceState.DS_EDIT) {
      throw new MandalaDatasourceError(
        'Registro já está sendo editado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: _validateInsert'
      )
    }
    if (this.getState() === MandalaDatasourceState.DS_INSERT) {
      throw new MandalaDatasourceError(
        'Registro já está sendo inserido. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: _validateInsert'
      )
    }
  }

  public insert = (value : T) => {
    this._validateInsert()
    this.dispatchEvent(MandalaDatasourceEventType.BEFORE_INSERT)
    this.oldRecordInsert = this.getCurrentRecord()
    this.oldRecnoInsert = this.getRecno()
    this.totalRecords++
    this.grandTotalRecords++
    let nextRecord = this.getTotalRecords()
    this.data[nextRecord - 1] = value;
    this.currentRecord = this.data[nextRecord - 1]
    this.currentRecno = nextRecord - 1
    this.dsState = MandalaDatasourceState.DS_INSERT
    this.dispatchEvent(MandalaDatasourceEventType.AFTER_SCROLL)
    this.dispatchEvent(MandalaDatasourceEventType.AFTER_INSERT)
  }

  private _validateDelete = () => {
    if (this.isEmpty()) {
      throw new MandalaDatasourceError(
        'Não há registros para remover. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: _validateDelete'
      )
    }
    if (this.isBOF()) {
      throw new MandalaDatasourceError(
        'Inicio do Datasource encontrado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: _validateDelete'
      )
    }
    if (this.isBOF()) {
      throw new MandalaDatasourceError(
        'Fim do Datasource encontrado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: _validateDelete'
      )
    }
    if (this.getState() === MandalaDatasourceState.DS_EDIT) {
      throw new MandalaDatasourceError(
        'Registro já está sendo editado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: _validateDelete'
      )
    }
    if (this.getState() === MandalaDatasourceState.DS_INSERT) {
      throw new MandalaDatasourceError(
        'Registro já está sendo inserido. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: _validateDelete'
      )
    }
  }

  public delete = (callback : Function) => {
    this._validateDelete()
    this.dispatchEvent(MandalaDatasourceEventType.BEFORE_DELETE)
    let index = -1
    this.allData.forEach((item, idx) => {
      if (this.currentRecno === item) {
        index = idx
      }
    })
    if (index >= 0) {
      this.allData.splice(index, 1)
    }
    this.data.splice(this.currentRecno, 1)
    this.totalRecords--
    this.grandTotalRecords--
    if (this.data.length === 0) this.currentRecord = undefined
    else this.currentRecord = this.data[this.currentRecno]
    this.dsState = MandalaDatasourceState.DS_BROWSE
    this.dispatchEvent(MandalaDatasourceEventType.AFTER_SCROLL)
    this.dispatchEvent(MandalaDatasourceEventType.AFTER_DELETE)

    if (callback) callback()
  }

  protected _validateEdit = () => {
    if (!this.isOpen()) {
      throw new MandalaDatasourceError(
        'Não é possível realizar EDIT com o dataSource fechado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: _validateEdit'
      )
    }
    if (this.isEmpty()) {
      throw new MandalaDatasourceError(
        'Não há registros para editar. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: _validateEdit'
      )
    }
    if (this.isBOF()) {
      throw new MandalaDatasourceError(
        'Inicio do Datasource encontrado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: _validateEdit'
      )
    }
    if (this.isEOF()) {
      throw new MandalaDatasourceError(
        'Fim do Datasource encontrado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: _validateEdit'
      )
    }
    if (this.getState() === MandalaDatasourceState.DS_EDIT) {
      throw new MandalaDatasourceError(
        'Registro já está sendo editado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: _validateEdit'
      )
    }
    if (this.getState() === MandalaDatasourceState.DS_INSERT) {
      throw new MandalaDatasourceError(
        'Registro já está sendo inserido. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: _validateEdit'
      )
    }
  }

  public edit = () => {
    this._validateEdit()
    this.dispatchEvent(MandalaDatasourceEventType.BEFORE_EDIT)
    this.dsState = MandalaDatasourceState.DS_EDIT
    this.currentRecord = cloneDeep(this.currentRecord)
    this.dispatchEvent(MandalaDatasourceEventType.AFTER_EDIT)
  }

  private _validatePost = () => {
    if (this.dsState === MandalaDatasourceState.DS_BROWSE) {
      throw new MandalaDatasourceError(
        'Registro não está sendo inserido ou editado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: _validatePost'
      )
    }
  }

  public post = (callback : Function) => {
    this._validatePost()
    this.dispatchEvent(MandalaDatasourceEventType.BEFORE_POST)
    if (this.dsState === MandalaDatasourceState.DS_EDIT) {
      this.data[this.getRecno()] = this.currentRecord
    }

    let index = -1
    this.allData.forEach((item, idx) => {
      if (item === this.currentRecord) {
        index = idx
      }
    })
    if (index >= 0) {
      this.allData[index] = this.currentRecord
    } else {
      this.allData.push(this.currentRecord)
    }

    this.dsState = MandalaDatasourceState.DS_BROWSE
    this.dispatchEvent(MandalaDatasourceEventType.AFTER_POST)
    if (callback) callback()
  }

  private _validateCancel = () => {
    if (this.dsState === MandalaDatasourceState.DS_BROWSE) {
      throw new MandalaDatasourceError(
        'Registro não está sendo inserido ou editado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: _validateCancel'
      )
    }
  }

  public cancel = () => {
    this._validateCancel()
    this.dispatchEvent(MandalaDatasourceEventType.BEFORE_CANCEL)
    if (this.dsState === MandalaDatasourceState.DS_INSERT) {
      this.data.splice(this.currentRecno, 1)
      this.currentRecord = this.oldRecordInsert
      this.currentRecno = this.oldRecnoInsert
      this.totalRecords--
      this.grandTotalRecords--
      this.dsState = MandalaDatasourceState.DS_BROWSE
      this.dispatchEvent(MandalaDatasourceEventType.AFTER_SCROLL)
    } else {
      this.currentRecord = this.data[this.currentRecno]
    }
    this.dsState = MandalaDatasourceState.DS_BROWSE
    this.dispatchEvent(MandalaDatasourceEventType.AFTER_CANCEL)
  }

  public disabledAllListeners = () => {
    this._enableListeners = false
  }

  public enableAllListeners = () => {
    this._enableListeners = true
  }

  protected dispatchEvent = (
    event: MandalaDatasourceEventType,
    error: any | undefined = undefined,
    fieldName: string | undefined = undefined
  ) => {
    if (this._enableListeners) {
      let listToRemove: any[] = []
      this.listeners.forEach((listener) => {
        if (listener.event === event) {
          if (fieldName) {
            if (listener.fieldName) {
              let fields: any[] = []
              if (Array.isArray(listener.fieldName)) {
                fields = listener.fieldName
              } else {
                fields.push(listener.fieldName)
              }
              fields.forEach((item) => {
                if (item.includes(fieldName)) {
                  listener.dispatch(event, error, fieldName)
                }
              })
            }
          } else {
            if (listener.dispatch === undefined) {
              listToRemove.push(listener)
            } else {
              listener.dispatch(event, error)
            }
          }
        }
      })
      listToRemove.forEach((item) => {
        this.removeEventListener(item)
      })
    }
  }

  public addEventListener  = (listener: MandalaDatasourceEventListener) => {
    this.listeners.push(listener)
  }

  public addEventsListener = (listeners: MandalaDatasourceEventListener[]) => {
    listeners.forEach((listener) => {
      this.listeners.push(listener)
    })
  }

  public removeEventListener = (listener: MandalaDatasourceEventType) =>{
    this.removeEventListener(listener)
  }

  removeEventsListener = (listeners: MandalaDatasourceEventType[]) => {
    listeners.forEach((listener: MandalaDatasourceEventType) => {
        this.removeEventListener(listener)
      })
  }  
}

class MandalaLocalDatasource<T> extends MandalaDatasource<T> {
  private cloneOnEdit: boolean
  constructor(data: any[], name: string) {
    super(name)
    this.open(data, true);
    this.cloneOnEdit = true;
  }

  open(data: T[] = [], cloneOnEdit: boolean = false) {
    this.close()
    this.dispatchEvent(MandalaDatasourceEventType.BEFORE_OPEN)
    this.data = []
    this.allData = []
    this.active = true
    this.allData = data
    if (!data) {
      this.data = []
      this.allData = []
    }
    this.data = this.allData
    this.totalRecords = this.data.length
    this.grandTotalRecords = this.allData.length
    this.first()
    this.dispatchEvent(MandalaDatasourceEventType.AFTER_OPEN)
    this.cloneOnEdit = cloneOnEdit
  }

  close = () => {
    super.close()
    this.data = []
    this.totalRecords = this.data.length
    this.grandTotalRecords = this.data.length
    this.dispatchEvent(MandalaDatasourceEventType.AFTER_CLOSE)
  }

  public edit = () => {
    this._validateEdit()
    this.dispatchEvent(MandalaDatasourceEventType.BEFORE_EDIT)
    this.dsState = MandalaDatasourceState.DS_EDIT
    if (this.cloneOnEdit) this.currentRecord = cloneDeep(this.currentRecord)
    this.dispatchEvent(MandalaDatasourceEventType.AFTER_EDIT)
  }

  public refresh = () => {
    if (this.getState() != MandalaDatasourceState.DS_BROWSE) {
      throw new MandalaDatasourceError(
        'Registro atual está sendo inserido ou editado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: refresh'
      )
    }
    this.close()
    this.dispatchEvent(MandalaDatasourceEventType.BEFORE_OPEN)
    this.data = this.filter ? this.allData.filter(this.filter) : this.allData
    this.totalRecords = this.data.length
    this.active = true
    this.dispatchEvent(MandalaDatasourceEventType.AFTER_OPEN)
  }

  public append = (record : T) => {
    if (this.getState() === MandalaDatasourceState.DS_EDIT) {
      throw new MandalaDatasourceError(
        'Registro já está sendo editado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: append'
      )
    }
    if (this.getState() === MandalaDatasourceState.DS_INSERT) {
      throw new MandalaDatasourceError(
        'Registro já está sendo inserido. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: append'
      )
    }

    if (!this.data) {
      this.data = []
      this.allData = []
      this.grandTotalRecords = 0
    }

    this.allData.push(record)
    this.data = this.filter ? this.allData.filter(this.filter) : this.allData
    this.totalRecords = this.data.length
    this.grandTotalRecords++
    if (!this.gotoRecordByData(record)) {
      this.currentRecord = undefined
      this.currentRecno = -1
    }
    this.dispatchEvent(MandalaDatasourceEventType.AFTER_POST)
    this.dispatchEvent(MandalaDatasourceEventType.AFTER_SCROLL)
  }

  replace = (record) => {
    if (this.getState() === MandalaDatasourceState.DS_EDIT) {
      throw new MandalaDatasourceError(
        'Registro já está sendo editado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: replace'
      )
    }
    if (this.getState() === MandalaDatasourceState.DS_INSERT) {
      throw new MandalaDatasourceError(
        'Registro já está sendo inserido. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: replace'
      )
    }
    if (!this.data) {
      throw new MandalaDatasourceError(
        'Fonte de dados vazia não é possível fazer um replace no registro. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: replace'
      )
    }

    let index = -1
    this.allData.forEach((item, idx) => {
      if (item === this.currentRecord) {
        index = idx
      }
    })
    if (index >= 0) {
      this.allData[index] = record
    }
    this.data = this.filter ? this.allData.filter(this.filter) : this.allData
    if (!this.gotoRecordByData(record)) {
      this.currentRecord = undefined
      this.currentRecno = -1
    }
    this.dispatchEvent(MandalaDatasourceEventType.AFTER_POST)
    this.dispatchEvent(MandalaDatasourceEventType.AFTER_SCROLL)
  }

  public appendFirst = (record) => {
    if (this.getState() === MandalaDatasourceState.DS_EDIT) {
      throw new MandalaDatasourceError(
        'Registro já está sendo editado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: appendFirst'
      )
    }
    if (this.getState() === MandalaDatasourceState.DS_INSERT) {
      throw new MandalaDatasourceError(
        'Registro já está sendo inserido. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: appendFirst'
      )
    }
    if (this.getState() === MandalaDatasourceState.DS_INSERT) {
      throw new MandalaDatasourceError(
        'Não é possível utilizar o método appendFirst com um filtro aplicado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: appendFirst'
      )
    }

    if (!this.data) {
      this.data = []
      this.allData = []
      this.grandTotalRecords = 0
    }

    this.data.splice(0, 0, record)
    this.allData = this.data
    this.totalRecords = this.data.length
    this.grandTotalRecords = this.data.length
    this.currentRecord = record
    this.currentRecno = 0
    this.dispatchEvent(MandalaDatasourceEventType.AFTER_POST)
    this.dispatchEvent(MandalaDatasourceEventType.AFTER_SCROLL)
  }

  public appendAtIndex = (record, index) => {
    if (this.getState() === MandalaDatasourceState.DS_EDIT) {
      throw new MandalaDatasourceError(
        'Registro já está sendo editado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: appendAtIndex'
      )
    }
    if (this.getState() === MandalaDatasourceState.DS_INSERT) {
      throw new MandalaDatasourceError(
        'Registro já está sendo inserido. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: appendAtIndex'
      )
    }
    if (this.getState() === MandalaDatasourceState.DS_INSERT) {
      throw new MandalaDatasourceError(
        'Não é possível utilizar o método appendAtIndex com um filtro aplicado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: appendAtIndex'
      )
    }

    if (!this.data) {
      this.data = []
      this.allData = []
      this.grandTotalRecords = 0
    }

    this.data.splice(index, 0, record)
    this.allData = this.data
    this.totalRecords = this.data.length
    this.grandTotalRecords = this.data.length
    this.currentRecord = record
    this.currentRecno = index
    this.dispatchEvent(MandalaDatasourceEventType.AFTER_POST)
    this.dispatchEvent(MandalaDatasourceEventType.AFTER_SCROLL)
  }
}

class MandalaRemoteDatasource extends MandalaDatasource {
  ajaxConfig: any
  ajaxPageConfigHandler: undefined
  ajaxPostConfigHandler: undefined
  ajaxDeleteConfigHandler: undefined
  ajaxOpenConfigHandler: undefined
  validatePostResponse: undefined
  validateDeleteResponse: undefined
  storePostResultToRecord: boolean
  executed: boolean
  config: any
  constructor(ajaxConfig, name) {
    super(name)
    this.ajaxConfig = ajaxConfig
    this.ajaxPageConfigHandler = undefined
    this.ajaxPostConfigHandler = undefined
    this.ajaxDeleteConfigHandler = undefined
    this.ajaxOpenConfigHandler = undefined
    this.validatePostResponse = undefined
    this.validateDeleteResponse = undefined
    this.storePostResultToRecord = true
    this.executed = false
  }

  public setValidatePostResponse = (value) => {
    this.validatePostResponse = value
  }

  public setValidateDeleteResponse = (value) => {
    this.validateDeleteResponse = value
  }

  public setStorePostResultToRecord = (value) => {
    this.storePostResultToRecord = value
  }

  public setAjaxPageConfigHandler = (handler) => {
    this.ajaxPageConfigHandler = handler
  }

  public setAjaxPostConfigHandler = (handler) => {
    this.ajaxPostConfigHandler = handler
  }

  public setAjaxDeleteConfigHandler = (handler) => {
    this.ajaxDeleteConfigHandler = handler
  }

  public setAjaxOpenConfigHandler = (handler) => {
    this.ajaxOpenConfigHandler = handler
  }

  public open(config, callback) {
    this.close()
    this.dispatchEvent(MandalaDatasourceEventType.BEFORE_OPEN)
    this.data = []
    this.allData = []
    this.active = true
    if (Array.isArray(config) && !callback) {
      this.allData = config
      if (!config) {
        this.data = []
        this.allData = []
      }
      this.data = this.allData
      this.totalRecords = this.data.length
      this.grandTotalRecords = this.allData.length
      this.first()
      this.dispatchEvent(MandalaDatasourceEventType.AFTER_OPEN)
    } else {
      if (config && config != null) {
        this.executeAjax(
          config ? config : this.config,
          dataSourceEvents.AFTER_OPEN,
          callback
        )
      } else {
        if (this.ajaxOpenConfigHandler && this.ajaxOpenConfigHandler !== null) {
          let openConfig = this.ajaxOpenConfigHandler()
          this.executeAjax(openConfig, dataSourceEvents.AFTER_OPEN, callback)
        } else {
          this.dispatchEvent(MandalaDatasourceEventType.AFTER_OPEN)
        }
      }
    }
  }

  public refresh = () => {
    if (this.ajaxConfig) {
      this.executeAjax(this.ajaxConfig, dataSourceEvents.AFTER_OPEN, callback)
    }
  }

  public append = (record) => {
    if (this.getState() === MandalaDatasourceState.DS_EDIT) {
      throw new MandalaDatasourceError(
        'Registro já está sendo editado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: append'
      )
    }
    if (this.getState() === MandalaDatasourceState.DS_INSERT) {
      throw new MandalaDatasourceError(
        'Registro já está sendo inserido. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: append'
      )
    }

    if (!this.data) {
      this.data = []
      this.allData = []
      this.grandTotalRecords = 0
    }

    this.allData.push(record)
    this.data = this.filter ? this.allData.filter(this.filter) : this.allData
    this.totalRecords = this.data.length
    this.grandTotalRecords++
    if (!this.gotoRecordByData(record)) {
      this.currentRecord = undefined
      this.currentRecno = -1
    }
    this.dispatchEvent(MandalaDatasourceEventType.AFTER_POST)
    this.dispatchEvent(MandalaDatasourceEventType.AFTER_SCROLL)
  }

  public replace = (record) => {
    if (this.getState() === MandalaDatasourceState.DS_EDIT) {
      throw new MandalaDatasourceError(
        'Registro já está sendo editado. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: replace'
      )
    }
    if (this.getState() === MandalaDatasourceState.DS_INSERT) {
      throw new MandalaDatasourceError(
        'Registro já está sendo inserido. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: replace'
      )
    }
    if (!this.data) {
      throw new MandalaDatasourceError(
        'Fonte de dados vazia não é possível fazer um replace no registro. Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: replace'
      )
    }

    let index = -1
    this.allData.forEach((item, idx) => {
      if (item === this.currentRecord) {
        index = idx
      }
    })
    if (index >= 0) {
      this.allData[index] = record
    }
    this.data = this.filter ? this.allData.filter(this.filter) : this.allData
    if (!this.gotoRecordByData(record)) {
      this.currentRecord = undefined
      this.currentRecno = -1
    }
    this.dispatchEvent(MandalaDatasourceEventType.AFTER_POST)
    this.dispatchEvent(MandalaDatasourceEventType.AFTER_SCROLL)
  }

  public post = (callback) => {
    if (!this.ajaxPostConfigHandler || !this.validatePostResponse) {
      let error =
        "Para salvar dados remotamente é necessário configurar 'setAjaxPostConfigHandler' e 'setValidatePostResponse' "
      this.dispatchEvent(MandalaDatasourceEventType.ON_ERROR, error)
      throw new MandalaDatasourceError(
        error + ' Fonte de dados: ' + this.getDataSourceName() + ' Método: post'
      )
    }
    this._validatePost()
    this.dispatchEvent(MandalaDatasourceEventType.BEFORE_POST)

    let ajaxPostConfig = this.ajaxPostConfigHandler(this.currentRecord)
    remoteApi
      .save(ajaxPostConfig)
      .then((response) => {
        if (this.validatePostResponse(response)) {
          if (this.dsState === MandalaDatasourceState.DS_EDIT) {
            this.data[this.getRecno()] = this.currentRecord
          }
          if (this.storePostResultToRecord === true) {
            let newObject = AnterosJacksonParser.convertJsonToObject(
              response.data
            )

            let index = -1
            this.allData.forEach((item, idx) => {
              if (item === this.currentRecord) {
                index = idx
              }
            })
            if (index >= 0) {
              this.allData[index] = newObject
            } else {
              this.allData.push(newObject)
            }

            this.data[this.getRecno()] = newObject
            this.currentRecord = newObject
          }
          this.dsState = MandalaDatasourceState.DS_BROWSE
          this.dispatchEvent(MandalaDatasourceEventType.AFTER_POST)
          if (callback) {
            callback()
          }
        }
      })
      .catch((error) => {
        if (callback) {
          callback(error)
        }
        this.dispatchEvent(MandalaDatasourceEventType.ON_ERROR, error)
      })
  }

  delete = (callback) => {
    if (!this.ajaxDeleteConfigHandler || !this.validateDeleteResponse) {
      let error =
        "Para remover dados remotamente é necessário configurar 'setAjaxDeleteConfigHandler' e 'setValidateDeleteResponse' "
      this.dispatchEvent(MandalaDatasourceEventType.ON_ERROR, error)
      throw new MandalaDatasourceError(
        error +
          ' Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: delete'
      )
    }
    this._validateDelete()
    this.dispatchEvent(MandalaDatasourceEventType.BEFORE_DELETE)
    let ajaxDeleteConfig = this.ajaxDeleteConfigHandler(this.currentRecord)
    remoteApi
      .delete(ajaxDeleteConfig)
      .then((response) => {
        if (this.validateDeleteResponse(response)) {
          let index = -1
          this.allData.forEach((item, idx) => {
            if (this.currentRecno === item) {
              index = idx
            }
          })
          if (index >= 0) {
            this.allData.splice(index, 1)
          }
          this.data.splice(this.currentRecno, 1)

          if (this.data.length === 0) this.currentRecord = undefined
          else this.currentRecord = this.data[this.currentRecno]
          this.totalRecords--
          this.grandTotalRecords--
          this.dsState = MandalaDatasourceState.DS_BROWSE
          this.dispatchEvent(MandalaDatasourceEventType.AFTER_SCROLL)
          this.dispatchEvent(MandalaDatasourceEventType.AFTER_DELETE)
        }
        if (callback) {
          callback()
        }
      })
      .catch((error) => {
        if (callback) {
          callback(error)
        }
        this.dispatchEvent(MandalaDatasourceEventType.ON_ERROR, error)
      })
  }

  goToPage = (page) => {
    if (!this.ajaxPageConfigHandler) {
      let error =
        "Para buscar dados paginados remotamente é necessário configurar 'setAjaxPageConfigHandler'"
      this.dispatchEvent(MandalaDatasourceEventType.ON_ERROR, error)
      throw new MandalaDatasourceError(
        error +
          ' Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: goToPage'
      )
    }
    this.dispatchEvent(MandalaDatasourceEventType.BEFORE_GOTO_PAGE)
    let ajaxPageConfig = this.ajaxPageConfigHandler(page)
    this.executeAjax(ajaxPageConfig, dataSourceEvents.AFTER_GOTO_PAGE)
  }

  goNextPage = () => {
    if (!this.ajaxPageConfigHandler) {
      let error =
        "Para buscar dados paginados remotamente é necessário configurar 'setAjaxPageConfigHandler'"
      this.dispatchEvent(MandalaDatasourceEventType.ON_ERROR, error)
      throw new MandalaDatasourceError(
        error +
          ' Fonte de dados: ' +
          this.getDataSourceName() +
          ' Método: goNextPage'
      )
    }
    this.dispatchEvent(MandalaDatasourceEventType.BEFORE_GOTO_PAGE)
    let ajaxPageConfig = this.ajaxPageConfigHandler(this.currentPage + 1)
    this.executeAjax(
      ajaxPageConfig,
      dataSourceEvents.AFTER_GOTO_PAGE,
      (error) => {
        if (!error) {
          this.currentPage = this.currentPage + 1
        }
      },
      true
    )
  }

  protected executeAjax = (ajaxConfig, event, callback, accumulated) => {
    this.executed = false
    remoteApi
      .get(ajaxConfig ? ajaxConfig : this.ajaxConfig)
      .then((response) => {
        this.setResponseValues(response)
        this.processResponseData(response, accumulated)
        this.executed = true
        this.dsState = MandalaDatasourceState.DS_BROWSE
        this.first()
        this.dispatchEvent(event)
        if (callback) {
          callback()
        }
      })
      .catch((error) => {
        if (this.executed) {
          if (callback) {
            callback(error)
          }
          throw new Error(error.name + ': ' + error.message)
        } else {
          if (callback) {
            callback(error)
          }
          this.dispatchEvent(MandalaDatasourceEventType.ON_ERROR, error)
        }
      })
  }

  protected processResponseData = (response, accumulated) => {
    if (response.data.hasOwnProperty(this.contentProperty)) {
      let temp = MandalaJacksonParser.convertJsonToObject(
        response.data[this.contentProperty]
      )
      if (temp === '') {
        this.allData = []
      } else {
        if (Array.isArray(temp))
          if (accumulated === true) {
            this.allData = this.allData.concat(temp)
          } else {
            this.allData = temp
          }
        else {
          if (accumulated === true) {
            if (!this.data) {
              this.allData = []
              this.allData.push(temp)
            } else {
              this.allData.push(temp)
            }
          }
          {
            this.allData = []
            this.allData.push(temp)
          }
        }
      }
      this.data = this.filter
        ? this.allData.filter(this.filter)
        : [].concat(this.allData)
      this.totalRecords = this.data.length
    } else {
      let temp = MandalaJacksonParser.convertJsonToObject(response.data)
      if (temp === '') {
        this.allData = []
      } else {
        if (Array.isArray(temp))
          if (accumulated === true) {
            this.allData = this.allData.concat(temp)
          } else {
            this.allData = temp
          }
        else {
          if (accumulated === true) {
            if (!this.allData) {
              this.allData = []
              this.allData.push(temp)
            } else {
              this.allData.push(temp)
            }
          }
          {
            this.allData = []
            this.allData.push(temp)
          }
        }
      }
      this.grandTotalRecords = this.allData.length
      this.data = this.filter
        ? this.allData.filter(this.filter)
        : [].concat(this.allData)
      this.totalRecords = this.data.length
    }
  }

  protected setResponseValues = (response) => {
    if (response.data.hasOwnProperty(this.totalPagesProperty)) {
      this.totalPages = response.data[this.totalPagesProperty]
    }

    if (response.data.hasOwnProperty(this.currentPageProperty)) {
      this.currentPage = response.data[this.currentPageProperty]
    }

    if (response.data.hasOwnProperty(this.sizeOfPageProperty)) {
      this.sizeOfPage = response.data[this.sizeOfPageProperty]
    }

    if (response.data.hasOwnProperty(this.totalRecordsProperty)) {
      this.totalRecords = response.data[this.totalRecordsProperty]
    }

    if (response.data.hasOwnProperty(this.grandTotalRecordsProperty)) {
      this.grandTotalRecords = response.data[this.grandTotalRecordsProperty]
    }
  }

  protected close() {
    super.close()
    this.data = []
    this.allData = []
    this.dispatchEvent(MandalaDatasourceEventType.AFTER_CLOSE)
  }
}

export {
  MandalaDatasource,
  MandalaLocalDatasource,
  MandalaRemoteDatasource,
  DATASOURCE_EVENTS,
  MandalaDatasourceState,
  MandalaDatasourceEventType
}
