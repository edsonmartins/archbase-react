import { Meta, Controls } from '@storybook/blocks';

<Meta title="Grid Layout"  />

# Archbase Grid Layout
Um poderoso sistema de layout de grid responsivo semelhante ao Bootstrap para React.


### Grid responsiva

Archbase Grid Layout fornece uma grid responsiva para o React inspirada em [Bootstrap](https://getbootstrap.com/docs/4.5/layout/grid/). Moreover, it has various additional powerful features, such as setting breakpoints and gutter widths through React's context.

Três componentes são fornecidos para criar grids responsivas: `ArchbaseContainer`, `ArchbaseRow`, and `ArchbaseCol`.

Um exemplo de como usá-los:

```tsx
import { ArchbaseContainer, ArchbaseRow, Col } from 'rs-archbase-react';

<ArchbaseContainer>
  <ArchbaseRow>
    <ArchbaseCol sm={4}>
      Uma das três colunas
    </ArchbaseCol>
    <ArchbaseCol sm={4}>
      Uma das três colunas
    </ArchbaseCol>
    <ArchbaseCol sm={4}>
      Uma das três colunas
    </ArchbaseCol>
  </ArchbaseRow>
</ArchbaseContainer>
```

### Utilitários responsivos

Ao lado da grid, dois componentes são fornecidos para mostrar ou ocultar o conteúdo: `ArchbaseVisible` e `ArchbaseHidden`.
A principal diferença entre esses dois componentes e as classes CSS semelhantes fornecidas pelo Bootstrap é que esses dois componentes não renderizam o conteúdo quando ele deveria estar oculto, em vez de apenas ocultá-lo com CSS.

Alguns exemplos de como usar esses componentes:

```tsx
import { ArchbaseVisible } from 'rs-archbase-react';

<p>
  <span>Sua classe de tela atual é </span>
  <ArchbaseVisible xs><strong>xs</strong></ArchbaseVisible>
  <ArchbaseVisible sm><strong>sm</strong></ArchbaseVisible>
  <ArchbaseVisible md><strong>md</strong></ArchbaseVisible>
  <ArchbaseVisible lg><strong>lg</strong></ArchbaseVisible>
  <ArchbaseVisible xl><strong>xl</strong></ArchbaseVisible>
  <ArchbaseVisible xxl><strong>xxl</strong></ArchbaseVisible>
  <span>.</span>
</p>
```

```tsx
import { ArchbaseVisible, ArchbaseHidden } from 'rs-archbase-react';

<ArchbaseVisible xs sm>
  <p>Parágrafo visível em extra pequeno e pequeno.</p>
</ArchbaseVisible>
<ArchbaseHidden xs sm>
  <p>Parágrafo oculto em extra pequeno e pequeno.</p>
</ArchbaseHidden>
<ArchbaseVisible md lg>
  <p>Parágrafo visível em médio e grande.</p>
</ArchbaseVisible>
<ArchbaseHidden md lg>
  <p>Parágrafo oculto em médio e grande.</p>
</ArchbaseHidden>
```

Além disso, o componente `ArchbaseScreenClassRender` é fornecido, para renderizar um componente de forma diferente com base na classe da tela. Um exemplo de como usar isso:
```tsx
import { ArchbaseScreenClassRender } from 'rs-archbase-react';

<ArchbaseScreenClassRender render={screenClass => (
  <p style={{ fontSize: ['lg', 'xl', 'xxl'].includes(screenClass) ? '2rem' : '1rem' }} >
    Screen class: {screenClass}
  </p>
)} />
```

Como alternativa, o gancho `useArchbaseScreenClass` pode ser usado para renderizar um componente de forma diferente com base na classe de tela. Alguns exemplos de como usar isso:

```tsx
import React from 'react';
import { useArchbaseScreenClass } from 'rs-archbase-react';

// componente responsivo com base na largura da tela
function Exemplo1() {
  const screenClass = useScreenClass();
  return (
    <p style={{ fontSize: ['lg', 'xl', 'xxl'].includes(screenClass) ? '2rem' : '1rem' }} >
      Screen class: {screenClass}
    </p>
  );
}

// componente responsivo com base na largura da div
function Exemplo2() {
  const elementRef = useRef(null);
  const screenClass = useArchbaseScreenClass(elementRef);
  return (
    <div ref={elementRef}>
      <p style={{ fontSize: ['lg', 'xl', 'xxl'].includes(screenClass) ? '2rem' : '1rem' }} >
        Screen class: {screenClass}
      </p>
    </div>
  );
}
```

## Configuration

As seguintes configurações podem ser configuradas para alterar o comportamento responsivo dos componentes da grid:


<table>
    <tr>
        <td>Contexto</td>
        <td>Valor padrão</td>
        <td>Descrição</td>
    </tr>
    <tr>
        <td>`breakpoints`</td>
        <td>`[576, 768, 992, 1200, 1600, 1920]`</td>
        <td>Os pontos de interrupção (largura mínima) dos dispositivos nas classes de tela `sm`, `md`, `lg`, `xl`, `xxl` e `xxxl`.</td>
    </tr>
    <tr>
        <td>`containerWidths`</td>
        <td>`[540, 740, 960, 1140, 1540, 1810]`</td>
        <td>As larguras do contêiner em pixels de dispositivos nas classes de tela `sm`, `md`, `lg`, `xl`, `xxl` e `xxxl`.</td>
    </tr>
    <tr>
        <td>`gutterWidth`</td>
        <td>`30`</td>
        <td>A largura da calha em pixels. Uma largura de medianiz de 30 significa 15px em cada lado de uma coluna.</td>
    </tr>
    <tr>
        <td>`gridColumns`</td>
        <td>`12`</td>
        <td>O número de colunas na grid.</td>
    </tr>
    <tr>
        <td>`defaultScreenClass`</td>
        <td>`xxl`</td>
        <td>A classe de tela usada quando a viewport não pode ser determinada usando `window`.</td>
    </tr>
    <tr>
        <td>`maxScreenClass`</td>
        <td>`xxl`</td>
        <td>A classe de tela máxima a ser usada.</td>
    </tr>
</table>


Essas configurações podem ser configuradas da seguinte maneira:

```javascript
import { setConfiguration } from 'rs-archbase-react';

setConfiguration({ defaultScreenClass: 'sm', gridColumns: 20 });
```
 
## API de contexto ScreenClass

Internamente, todo componente que requer o `screenClass` atual (que é uma versão de string legível por humanos do `window.innerWidth` relacionado aos pontos de interrupção do usuário) se inscreve em um `ArchbaseScreenClassProvider`. O provedor utiliza a [API React Context](https://reactjs.org/docs/context.html) para enviar a `screenClass` atual conforme ela é atualizada. Por padrão, cada instância de cada componente se inscreve em um provedor separado, criando ouvintes `resize` para cada um. Isso pode reduzir as renderizações durante um evento de redimensionamento de ~300 para 4 (um para cada ponto de interrupção), tornando a grid muito mais eficiente.
### Preciso mudar alguma coisa no meu código?

Essa nova API é totalmente opcional e as implementações atuais continuarão a funcionar. No entanto, para um aumento de desempenho significativo, você precisará adicionar o `ArchbaseScreenClassProvider` ao seu aplicativo, normalmente no nível mais alto na árvore do nó React (ou seja, App.tsx).

### Como uso o ArchbaseScreenClassProvider?

```jsx static
import React from 'react';
import { ArchbaseScreenClassProvider } from 'rs-archbase-react';

export default function App() {
  return (
    <ArchbaseScreenClassProvider>
      <Header />
      <Page />
      <Footer />
    </ArchbaseScreenClassProvider>
  );
}
```

Internamente, o `ArchbaseScreenClassProvider` anexa um ouvinte `resize` e atualiza `state.screenClass` exclusivamente quando um novo ponto de interrupção é atingido. O valor `state.screenClass` é então anexado a `ArchbaseScreenClassContext.Provider`. Componentes dependentes de ScreenClass são agrupados com `ArchbaseScreenClassResolver`, que verifica se há um provedor válido acima dele e fornece um se não houver.

O benefício de desempenho vem de _você_ adicionando um `ArchbaseScreenClassProvider` ao seu aplicativo que permite que os componentes `rs-archbase-react` assinem **uma fonte de verdade** para o ScreenClass.