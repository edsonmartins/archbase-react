const b="==",d="!=",h="<=",E=">=",l="<",g=">",L="=in=",A="=out=",R="=bt=",I="=nb=",V="=le=",Q="=ge=",_="=lt=",G="=gt=";function S(r){switch(r){case V:return h;case _:return l;case Q:return E;case G:return g;default:return r}}const q=/^=[a-z]+=$/;function v(r){return r.length>2&&q.test(r)}function P(r,e){switch(r){case b:case d:case h:case E:case l:case g:case L:case A:case R:case I:case V:case Q:case _:case G:return e===void 0||S(r)===S(e);default:return v(r)?e===void 0||r===e:!1}}const a=";",s=",",T="and",O="or";function w(r){switch(r){case T:return a;case O:return s;default:return r}}function y(r,e){switch(r){case a:case s:case T:case O:return e===void 0||w(r)===w(e);default:return!1}}const B=['"',"'","(",")",";",",","=","!","~","<",">"," ",`
`,"	","\r"],i={SELECTOR:"SELECTOR",VALUE:"VALUE",COMPARISON:"COMPARISON",LOGIC:"LOGIC"};function u(r){return r!=null&&Object.prototype.hasOwnProperty.call(r,"type")}function x(r){return u(r)&&r.type===i.SELECTOR}function D(r){return u(r)&&r.type===i.VALUE}function M(r,e){return u(r)&&r.type===i.COMPARISON&&(e===void 0||P(r.operator,e))}function c(r,e){return u(r)&&r.type===i.LOGIC&&(e===void 0||y(r.operator,e))}function $(r){return M(r)||c(r)}function f(r,e){return Object.defineProperty(r,"toString",{value:e,enumerable:!1,configurable:!1,writable:!1}),r}function j(r,e=!1){if(!e){if(typeof r!="string")throw new TypeError(`The "selector" has to be a "string", "${String(r)}" passed.`);if(!r||r.length===0)throw new Error('The "selector" cannot be an empty string.');const t=B.find(n=>r.indexOf(n)!==-1);if(t){const n=r.indexOf(t)+1;throw new Error(`The "selector" contains reserved character '${t}' at position ${n} in "${r}".`)}}return f({type:i.SELECTOR,selector:r},()=>`SelectorNode("${r}")`)}function z(r,e=!1){if(!e){if(typeof r!="string"&&!Array.isArray(r))throw new TypeError(`The "value" has to be a "string | string[]", "${String(r)}" passed.`);if(Array.isArray(r)&&r.length===0)throw new Error('The "value" cannot be an empty array.')}return f({type:i.VALUE,value:r},()=>`ValueNode(${JSON.stringify(r)})`)}function F(r,e,t,n=!1){if(!n){if(!x(r))throw new TypeError(`The "selector" has to be a "SelectorNode", "${String(r)}" passed.`);if(typeof e!="string")throw new TypeError(`The "operator" has to be a "SelectorNode", "${String(e)}" passed.`);if(!P(e))throw new TypeError(`The "operator" has to be a valid "ComparisonOperator", ${String(e)} passed.`);if(!D(t))throw new TypeError(`The "value" has to be a "ValueNode", "${String(t)}" passed.`)}return f({type:i.COMPARISON,left:r,operator:e,right:t},()=>`ComparisonNode(${r},${e},${t})`)}function J(r,e,t,n=!1){if(!n){if(!$(r))throw new TypeError(`The "left" has to be a "ExpressionNode", "${String(r)}" passed.`);if(typeof e!="string")throw new TypeError(`The "operator" has to be a "string", "${String(e)}" passed.`);if(!y(e))throw new TypeError(`The "operator" has to be a valid "LogicOperator", ${String(e)} passed.`);if(!$(t))throw new TypeError(`The "right" has to be a "ExpressionNode", "${String(t)}" passed.`)}return f({type:i.LOGIC,left:r,operator:e,right:t},()=>`LogicNode(${r},${e},${t})`)}const o={comparison(r,e,t){return F(j(r),e,z(Array.isArray(t)?t.map(n=>String(n)):String(t)))},eq(r,e){return o.comparison(r,b,e)},bt(r,e,t){return o.comparison(r,R,[e,t])},nb(r,e,t){return o.comparison(r,I,[e,t])},neq(r,e){return o.comparison(r,d,e)},le(r,e){return o.comparison(r,h,e)},lt(r,e){return o.comparison(r,l,e)},ge(r,e){return o.comparison(r,E,e)},gt(r,e){return o.comparison(r,g,e)},in(r,e){return o.comparison(r,L,e)},out(r,e){return o.comparison(r,A,e)},logic(r,e){if(!r.length)throw new Error("The logic expression builder requires at least one expression but none passed.");return r.slice(1).reduce((t,n)=>J(t,e,n),r[0])},and(...r){return o.logic(r,a)},or(...r){return o.logic(r,s)}},m={preferredQuote:'"',optimizeQuotes:!0},W={'"':/"|\\/g,"'":/'|\\/g};function X(r,e){return r.replace(W[e],"\\$&")}function N(r,e){let t=0;for(let n=0;n<r.length;++n)r[n]===e&&t++;return t}function k(r,{preferredQuote:e=m.preferredQuote,optimizeQuotes:t=m.optimizeQuotes}){if(t){const n=e==='"'?"'":'"';return N(r,n)<N(r,e)?n:e}return e}function H(r){return r.selector}function C(r,e){if(r===""||B.some(t=>r.includes(t))){const t=k(r,e);return`${t}${X(r,t)}${t}`}return r}function K(r,e){return Array.isArray(r.value)?`(${r.value.map(t=>C(t,e)).join(",")})`:C(r.value,e)}function Y(r,e){return`${H(r.left)}${r.operator}${K(r.right,e)}`}function Z(r,e){let t=p(r.left,e),n=p(r.right,e);y(r.operator,a)&&(c(r.left,s)&&(t=`(${t})`),c(r.right,s)&&(n=`(${n})`));const U=r.operator===T||r.operator===O?` ${r.operator} `:r.operator;return`${t}${U}${n}`}function p(r,e){if(M(r))return Y(r,e);if(c(r))return Z(r,e);throw new TypeError(`The "expression" has to be a valid "ExpressionNode", ${String(r)} passed.`)}function rr(r,e={}){if(e.preferredQuote!==void 0&&e.preferredQuote!=='"'&&e.preferredQuote!=="'")throw new TypeError(`Invalid "preferredQuote" option: ${e.preferredQuote}. Must be either " (the ASCII double quote character) or ' (the ASCII single quote character).`);return p(r,e)}export{o as b,rr as e};
