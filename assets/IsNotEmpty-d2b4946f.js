import{t as y}from"./i18next-a4b2730f.js";class M{constructor(t){this.groups=[],this.each=!1,this.context=void 0,this.type=t.type,this.name=t.name,this.target=t.target,this.propertyName=t.propertyName,this.constraints=t==null?void 0:t.constraints,this.constraintCls=t.constraintCls,this.validationTypeOptions=t.validationTypeOptions,t.validationOptions&&(this.message=t.validationOptions.message,this.groups=t.validationOptions.groups,this.always=t.validationOptions.always,this.each=t.validationOptions.each,this.context=t.validationOptions.context)}}class N{transform(t){const a=[];return Object.keys(t.properties).forEach(i=>{t.properties[i].forEach(s=>{const r={message:s.message,groups:s.groups,always:s.always,each:s.each},c={type:s.type,name:s.name,target:t.name,propertyName:i,constraints:s.constraints,validationTypeOptions:s.options,validationOptions:r};a.push(new M(c))})}),a}}function T(){if(typeof globalThis<"u")return globalThis;if(typeof global<"u")return global;if(typeof window<"u")return window;if(typeof self<"u")return self}class O{constructor(){this.validationMetadatas=new Map,this.constraintMetadatas=new Map}get hasValidationMetaData(){return!!this.validationMetadatas.size}addValidationSchema(t){new N().transform(t).forEach(i=>this.addValidationMetadata(i))}addValidationMetadata(t){const a=this.validationMetadatas.get(t.target);a?a.push(t):this.validationMetadatas.set(t.target,[t])}addConstraintMetadata(t){const a=this.constraintMetadatas.get(t.target);a?a.push(t):this.constraintMetadatas.set(t.target,[t])}groupByPropertyName(t){const a={};return t.forEach(i=>{a[i.propertyName]||(a[i.propertyName]=[]),a[i.propertyName].push(i)}),a}getTargetValidationMetadatas(t,a,i,s,r){const c=n=>typeof n.always<"u"?n.always:n.groups&&n.groups.length?!1:i,d=n=>!!(s&&(!r||!r.length)&&n.groups&&n.groups.length),f=(this.validationMetadatas.get(t)||[]).filter(n=>n.target!==t&&n.target!==a?!1:c(n)?!0:d(n)?!1:r&&r.length>0?n.groups&&!!n.groups.find(o=>r.indexOf(o)!==-1):!0),u=[];for(const[n,o]of this.validationMetadatas.entries())t.prototype instanceof n&&u.push(...o);const v=u.filter(n=>typeof n.target=="string"||n.target===t||n.target instanceof Function&&!(t.prototype instanceof n.target)?!1:c(n)?!0:d(n)?!1:r&&r.length>0?n.groups&&!!n.groups.find(o=>r.indexOf(o)!==-1):!0).filter(n=>!f.find(o=>o.propertyName===n.propertyName&&o.type===n.type));return f.concat(v)}getTargetValidatorConstraints(t){return this.constraintMetadatas.get(t)||[]}}function h(){const e=T();return e.classValidatorMetadataStorage||(e.classValidatorMetadataStorage=new O),e.classValidatorMetadataStorage}class l{static isValid(t){return t!=="isValid"&&t!=="getMessage"&&Object.keys(this).map(a=>this[a]).indexOf(t)!==-1}}l.CUSTOM_VALIDATION="customValidation";l.NESTED_VALIDATION="nestedValidation";l.PROMISE_VALIDATION="promiseValidation";l.CONDITIONAL_VALIDATION="conditionalValidation";l.WHITELIST="whitelistValidation";l.IS_DEFINED="isDefined";const w=new class{constructor(){this.instances=[]}get(e){let t=this.instances.find(a=>a.type===e);return t||(t={type:e,object:new e},this.instances.push(t)),t.object}};let p,g;function V(e){if(p)try{const t=p.get(e);if(t||!g||!g.fallback)return t}catch(t){throw t}return w.get(e)}class I{constructor(t,a,i=!1){this.target=t,this.name=a,this.async=i}get instance(){return V(this.target)}}function m(e){let t;if(e.validator instanceof Function){if(t=e.validator,V(O).getTargetValidatorConstraints(e.validator).length>1)throw`More than one implementation of ValidatorConstraintInterface found for validator on: ${e.target.name}:${e.propertyName}`}else{const i=e.validator;t=class{validate(r,c){return i.validate(r,c)}defaultMessage(r){return i.defaultMessage?i.defaultMessage(r):""}},h().addConstraintMetadata(new I(t,e.name,e.async))}const a={type:e.name&&l.isValid(e.name)?e.name:l.CUSTOM_VALIDATION,name:e.name,target:e.target,propertyName:e.propertyName,validationOptions:e.options,constraintCls:t,constraints:e.constraints};h().addValidationMetadata(new M(a))}function S(e,t){return a=>{const i=t&&t.each?`${y("archbase:each value in ")}`:"";return e(i,a)}}function b(e,t){return function(a,i){m({name:e.name,target:a.constructor,propertyName:i,options:t,constraints:e.constraints,validator:e.validator})}}const E="isNotEmpty";function A(e){return e!==""&&e!==null&&e!==void 0}function F(e){return b({name:E,validator:{validate:(t,a)=>A(t),defaultMessage:S(t=>t+`${y("archbase:$property should not be empty")}`,e)}},e)}export{F as I,l as V,V as a,M as b,b as c,S as d,h as g};
